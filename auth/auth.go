package auth

import (
	"errors"
	"net/http"
	"parkme-api/auth/cookies"
	"parkme-api/auth/identity"
	"parkme-api/security"
	"parkme-api/util/encodeutil"
	"parkme-api/util/hashutil"
	"parkme-api/util/jsonutil"
	"strings"

	"gopkg.in/mgo.v2/bson"
)

// The keys that are used in the request header to authorize the user
const (
	AuthorizationHeader = "Authorization"
	AuthorizationScheme = "GOST-TOKEN"
)

// Errors generated by the auth package
var (
	ErrInvalidScheme           = errors.New("The used authorization scheme is invalid or not supported")
	ErrInvalidGhostToken       = errors.New("The given token is expired or invalid")
	ErrInvalidUser             = errors.New("There is no application user with the given ID")
	ErrDeactivatedUser         = errors.New("The current user account is deactivated or inexistent")
	ErrInexistentClientDetails = errors.New("Missing client details. Cannot create authorization for anonymous client")
	ErrPasswordMismatch        = errors.New("The entered password is incorrect")

	errAnonymousUser = errors.New("The user has no identity")
)

// GenerateUserAuth generates a new parkme-api-token, saves it in the database and returns it to the client
func GenerateUserAuth(userID bson.ObjectId, password string, clientDetails *cookies.Client) (string, error) {
	var user *identity.ApplicationUser
	var isUserExistent bool

	if user, isUserExistent = identity.IsUserExistent(userID); !isUserExistent {
		return ErrInvalidUser.Error(), ErrInvalidUser
	}

	if !hashutil.MatchHashString(user.Password, password) {
		return ErrPasswordMismatch.Error(), ErrPasswordMismatch
	}

	session, err := cookies.NewSession(userID, user.AccountType, clientDetails)
	if err != nil {
		return err.Error(), err
	}

	err = session.Save()
	if err != nil {
		return err.Error(), err
	}

	ghostToken, err := generateGostToken(session)

	return ghostToken, err
}

// Authorize tries to authorize an existing parkme-apiToken
func Authorize(httpHeader http.Header) (*identity.Identity, error) {
	ghostToken, err := extractGostToken(httpHeader)
	if err != nil {
		if err == errAnonymousUser {
			return identity.NewAnonymous(), nil
		}

		return nil, err
	}

	encryptedToken, err := encodeutil.Decode([]byte(ghostToken))
	if err != nil {
		return nil, err
	}

	jsonToken, err := security.Decrypt(encryptedToken)
	if err != nil {
		return nil, err
	}

	cookie := new(cookies.Session)
	err = jsonutil.DeserializeJSON(jsonToken, cookie)
	if err != nil {
		return nil, err
	}

	dbCookie, err := cookies.GetSession(cookie.Token)
	if err != nil || dbCookie == nil {
		return nil, ErrDeactivatedUser
	}

	if !identity.IsUserActivated(dbCookie.UserID) {
		return nil, ErrDeactivatedUser
	}

	go dbCookie.ResetToken()

	return identity.New(dbCookie), nil
}

func generateGostToken(session *cookies.Session) (string, error) {
	jsonToken, err := jsonutil.SerializeJSON(session)
	if err != nil {
		return err.Error(), err
	}

	encryptedToken, err := security.Encrypt(jsonToken)
	if err != nil {
		return err.Error(), err
	}

	ghostToken := encodeutil.Encode(encryptedToken)

	return string(ghostToken), nil
}

func extractGostToken(httpHeader http.Header) (string, error) {
	var apiToken string

	if apiToken = httpHeader.Get(AuthorizationHeader); len(apiToken) == 0 {
		return errAnonymousUser.Error(), errAnonymousUser
	}

	if !strings.Contains(apiToken, AuthorizationScheme) {
		return ErrInvalidScheme.Error(), ErrInvalidScheme
	}

	apiTokenValue := strings.TrimPrefix(apiToken, AuthorizationScheme)
	apiTokenValue = strings.TrimSpace(apiTokenValue)

	if len(apiTokenValue) == 0 {
		return ErrInvalidGhostToken.Error(), ErrInvalidGhostToken
	}

	return apiTokenValue, nil
}
